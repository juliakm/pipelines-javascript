variables:
 GLOBAL_MYSECRET: $(mySecret) # this will not work because the variable needs to be mapped as env
 GLOBAL_MY_MAPPED_ENV_VAR: foo # this will not work because the variable needs to be mapped as env

steps:

- powershell: |
    # Using an input-macro:
    Write-Host "This works: $(mySecret)"

    # Using the env var directly:
    Write-Host "This does not work: $env:MYSECRET"

    # Using the env var through the variables mapping will not work:
    Write-Host "This does not work either: $env:GLOBAL_MYSECRET"

    # Using the global var mapped in the pipeline. It is not a secret var:
    Write-Host "This works: $env:GLOBAL_MY_MAPPED_ENV_VAR" 

    # Using the mapped env var:
    Write-Host "This works: $env:MY_MAPPED_ENV_VAR"    # Recommended

  env:
    MY_MAPPED_ENV_VAR: $(mySecret) # right way to map to an env variable


# variables:
# - group: my-variable-group
# - name: my-passed-variable
#   value: $[variables.myhello]

# steps:
# - script: echo $(myhello) # uses macro syntax
# - script: echo $(my-passed-variable) 


# variables:
# - name: one
#   value: initialValue 

# steps:
#   - script: |
#       echo ${{ variables.one }} # outputs initialValue
#       echo $(one)
#     displayName: First variable pass
#   - script: echo '##vso[task.setvariable variable=one]secondValue'
#     displayName: Set new variable value
#   - script: |
#       echo ${{ variables.one }} # outputs initialValue
#       echo $(one) # will be initialValue
#     displayName: Second variable pass
  
  # bash: |
  #     echo $(foo)            # This will be bar
  #     echo '##vso[task.setvariable variable=foo]baz'
  #     echo $(foo)            # This will also be bar, $(foo) expands before the step
  # - bash: echo $(foo)        # This will be baz. The variable is expanded just before the step


# parameters:
# - name: myArray
#   type: object
#   default:
#     - FOO
#     - BAR
#     - ZOO

# variables:
#    A: ${{ join(';',parameters.myArray) }} # outputs FOO;BAR;ZOO

# steps:
#   - script: echo $A